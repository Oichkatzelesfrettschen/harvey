# Step 7: Run Harvey OS in QEMU (Native Architecture Image)

After successfully building Harvey OS for your native architecture, the next exciting step is to boot and run it using QEMU (Quick EMUlator). QEMU allows you to run Harvey OS as a virtual machine on your current operating system. The `setup-harvey-dev-env.sh` script should have installed QEMU and its system emulation components.

## 7.1. Prerequisites

*   **Harvey OS Built:** You must have completed Step 6 and have a successful native build of Harvey OS.
*   **QEMU Installed:** `setup-harvey-dev-env.sh` should have installed the necessary QEMU packages (e.g., `qemu-system-x86`, `qemu-system-arm`). You can verify with `qemu-system-x86_64 --version`.
*   **Artifact Locations:** You need to know the location of your compiled kernel and a disk image (if Harvey OS uses one for booting). These paths are specific to Harvey OS's build output.
    *   Example kernel path (for x86_64): `$HARVEY_ROOT/src/harvey-os/sys/src/9/pc/9pc64`
    *   Example disk image path: `$HARVEY_ROOT/src/harvey-os/disk.img` (This might be generated by the build, or you might need to create/obtain a suitable one).
    *   **Note:** These paths are illustrative. Consult Harvey OS's specific documentation or build output to find the correct paths for your kernel and disk image. Some systems might boot directly from the kernel without a separate disk image for the initial boot, or use a ramdisk.

*   **Current Directory:** It's often convenient to run QEMU commands from the root of the Harvey OS source tree (`$HARVEY_ROOT/src/harvey-os/`), as paths to kernel/disk images might be relative from there.

## 7.2. Basic QEMU Command Structure

A typical QEMU command to boot a PC-like operating system (e.g., Harvey OS on x86_64) looks something like this:

```bash
qemu-system-x86_64 [options] -kernel <path_to_kernel> -hda <path_to_disk_image>
```

Key options often include:
*   `qemu-system-x86_64`: The QEMU command for x86_64 system emulation.
*   `-kernel <path>`: Specifies the path to the kernel image to boot.
*   `-hda <path>` or `-drive file=<path>,format=raw,index=0,media=disk`: Specifies the primary hard disk image. The format might be `raw`, `qcow2`, etc.
*   `-m <size>`: Sets the amount of RAM for the virtual machine (e.g., `-m 512M` for 512 MB, `-m 1G` for 1 GB).
*   `-vga <type>`: Sets the VGA card type (e.g., `-vga std` for standard VGA, `-vga virtio` for VirtIO VGA).
*   `-netdev user,id=net0 -device e1000,netdev=net0`: A common way to set up user-mode networking, providing internet access to the guest.
*   `-nographic`: Runs QEMU without a graphical window (output to terminal). Useful for systems that primarily use a serial console.
*   `-append "<boot_arguments>"`: Appends arguments to the kernel command line.

**Harvey OS Specifics:**
Harvey OS might have a preferred or standard QEMU invocation. Look for scripts like `run_qemu.sh` or similar within the Harvey OS source tree, or check its documentation, as these often contain optimized QEMU settings.

## 7.3. Running Harvey OS (x86_64 Example)

Assuming your native build is for x86_64 and you have the kernel and a disk image:

1.  **Navigate to Harvey OS Source Directory:**
    ```bash
    cd $HARVEY_ROOT/src/harvey-os
    ```

2.  **Execute the QEMU Command:**
    Replace the placeholder paths with your actual kernel and disk image paths.
    ```bash
    # Example QEMU command (ADAPT THIS TO HARVEY OS SPECIFICS):
    qemu-system-x86_64 \
        -kernel sys/src/9/pc/9pc64 \
        -hda disk.img \
        -m 1G \
        -vga std \
        -netdev user,id=net0 -device e1000,netdev=net0 \
        -serial stdio
        # The -serial stdio option often redirects the guest's serial console
        # (which Harvey OS might use by default) to your host terminal.
        # If Harvey OS uses a graphical console by default, you might omit -serial stdio
        # or use -nographic if you only want serial.
    ```
    If Harvey OS provides a run script (e.g., `scripts/run_qemu_nox.sh` which was listed in the initial `ls()` output of the repository), it's highly recommended to use that:
    ```bash
    # Example if such a script exists and is configured for native boot:
    # ./scripts/run_qemu_nox.sh
    ```

## 7.4. Interacting with Harvey OS in QEMU

*   A new QEMU window might open (unless you used `-nographic` or `-serial stdio` and it's a serial-only guest).
*   You should see Harvey OS boot messages.
*   Eventually, you might get a login prompt or be directly logged in, depending on Harvey OS's default configuration.
    *   Common Plan 9 style login: user `none` (no password) or `glenda`.
*   Try basic commands available in Harvey OS (e.g., `ls`, `cat /dev/time`, `echo hello`, `rc`, `sam` if graphical).

## 7.5. Exiting QEMU

*   **Graphical Window:** Simply closing the QEMU window will usually shut down or power off the VM.
*   **Serial Console (`-nographic` or `-serial stdio`):**
    *   QEMU monitor: Press `Ctrl-a c` to switch to the QEMU monitor console, then type `quit` or `q` and press Enter.
    *   If the guest OS has a shutdown command (e.g., `fshalt` in Plan 9), use that first, then quit QEMU.
    *   `Ctrl-c` in the host terminal running QEMU might forcefully kill it, but a clean shutdown from the guest or QEMU monitor is preferred.

## 7.6. Troubleshooting

*   **QEMU command not found:** Ensure QEMU was installed correctly in Step 2 and your `PATH` is correct.
*   **Kernel/Disk image not found:** Double-check the paths to your build artifacts.
*   **VM doesn't boot (hangs, kernel panic):**
    *   There might be an issue with your build. Try a clean build (Step 6).
    *   QEMU options might be incorrect for Harvey OS. Consult Harvey OS documentation or existing run scripts.
    *   Insufficient RAM (`-m` option).
*   **No network:** QEMU networking can be tricky. The `-netdev user,... -device e1000,...` combo is common for basic NATted internet access. Consult Harvey OS documentation if specific network services from the guest are needed by the host or other machines.
*   **Mouse/Keyboard issues in graphical mode:** Ensure QEMU has input focus. Sometimes specific USB emulation options might be needed for unusual input devices, but this is rare for standard keyboards/mice.

## 7.7. Architectural Alignment

Running Harvey OS in QEMU, even for the native architecture, aligns with several architectural goals:

*   **Validation of Tier 1 Architectures ([docs/architecture/tier-criteria.md](../../docs/architecture/tier-criteria.md)):** Successfully booting and interacting with a natively compiled image in QEMU provides a basic but essential validation of the OS's functionality on that (likely Tier 1) architecture.
*   **Virtualization for Testing (CI Strategy - [docs/ci-strategy.md](../../docs/ci-strategy.md#33-testing-strategy)):** The ability to run Harvey OS in QEMU is fundamental to the CI strategy, which relies on emulation for testing non-native targets and for providing consistent test environments. This step demonstrates that core capability.
*   **Developer Workflow & Debugging:** QEMU provides debugging capabilities (e.g., GDB stub) that are invaluable for kernel and system-level development, supporting a more robust development cycle. This is part of providing a good developer experience as per the [Contribution Guide](../../docs/community/contribution-guide.md).
*   **Portability ([ARCHITECTURAL_MANIFESTO.md](../../ARCHITECTURAL_MANIFESTO.md#2-core-identity-what-is-harvey-os-in-2025-and-beyond)):** While this step runs a native build, the ease of running under QEMU is an indicator of the OS's design for portability and its relative independence from specific bare-metal hardware quirks for basic functionality.

## 7.8. Next Steps

Congratulations! You've successfully built and run your native Harvey OS image in QEMU. Now you can explore its features.

The next step in this guide is **Step 8: Cross-Compile for a Target Architecture (e.g., ARM64)**, where you'll build Harvey OS for a different type of processor.
